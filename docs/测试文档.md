# 测试与文档指南

## 概述

本文档描述了 MaiMaiNotePad 后端项目的测试策略、测试运行方法和开发指南。项目采用 pytest 作为测试框架，支持单元测试、集成测试、属性测试和端到端测试。

当前测试覆盖率：**79%** (5477 行代码，1176 行未覆盖)
测试数量：**1366 个测试** (1355 通过，10 失败，1 跳过)
测试执行时间：**451 秒** (7分31秒)

## 项目结构

测试文件组织在 `tests/` 目录下，镜像 `app/` 的目录结构：

```
tests/
├── __init__.py
├── conftest.py               # 测试配置和 fixtures
├── test_auth.py              # 认证相关测试
├── test_users.py             # 用户相关测试
├── test_knowledge.py         # 知识库相关测试
├── test_persona.py           # 人设卡相关测试
└── services/                 # 服务层测试
    ├── test_user_service.py
    ├── test_auth_service.py
    ├── test_knowledge_service.py
    └── test_persona_service.py
```

## 测试执行指南

### 运行所有测试

```bash
# 使用 pytest 运行所有测试
pytest

# 显示详细输出
pytest -v

# 显示测试进度
pytest -v --tb=short
```

### 运行特定类型的测试

```bash
# 只运行单元测试
pytest tests/unit/ -v

# 只运行集成测试
pytest tests/integration/ -v

# 只运行属性测试
pytest tests/property/ -v

# 只运行端到端测试
pytest tests/e2e/ -v
```

### 运行特定模块的测试

```bash
# 运行认证相关测试
pytest tests/integration/routes/test_auth_routes.py -v

# 运行用户服务测试
pytest tests/unit/services/test_user_service.py -v

# 运行知识库相关测试
pytest tests/integration/routes/test_knowledge_routes.py -v

# 运行特定测试类
pytest tests/integration/routes/test_auth_routes.py::TestLogin -v

# 运行特定测试函数
pytest tests/integration/routes/test_auth_routes.py::TestLogin::test_login_with_valid_credentials_json -v
```

### 运行失败的测试

```bash
# 只运行上次失败的测试
pytest --lf

# 先运行失败的测试，再运行其他测试
pytest --ff
```

### 并行运行测试

```bash
# 使用所有 CPU 核心并行运行
pytest -n auto

# 使用指定数量的进程
pytest -n 4
```

### 生成测试覆盖率报告

```bash
# 生成终端覆盖率报告
pytest --cov=app --cov-report=term

# 生成 HTML 覆盖率报告
pytest --cov=app --cov-report=html

# 生成详细的覆盖率报告（显示未覆盖的行）
pytest --cov=app --cov-report=term-missing

# 生成 JSON 格式的覆盖率报告
pytest --cov=app --cov-report=json

# 查看 HTML 覆盖率报告
open htmlcov/index.html  # macOS
xdg-open htmlcov/index.html  # Linux
```

### 测试覆盖率统计

当前测试覆盖率：**79%**

#### 模块覆盖率详情

| 模块 | 覆盖率 | 说明 |
|------|--------|------|
| **Models** | 98-100% | 数据模型和 Schema |
| **Services** | 66-99% | 业务逻辑层 |
| **API Routes** | 65-100% | API 端点 |
| **Core** | 58-100% | 核心功能 |
| **Utils** | 22-82% | 工具函数 |

#### 高覆盖率模块 (≥90%)

- `app/models/database.py`: 100%
- `app/api/routes/dictionary.py`: 100%
- `app/services/email_service.py`: 100%
- `app/services/message_service.py`: 99%
- `app/models/schemas.py`: 98%
- `app/services/auth_service.py`: 93%
- `app/core/logging.py`: 92%
- `app/api/routes/auth.py`: 90%
- `app/api/response_util.py`: 90%

#### 需要改进的模块 (<80%)

- `app/utils/file.py`: 22% - 文件工具函数
- `app/utils/websocket.py`: 43% - WebSocket 工具
- `app/main.py`: 52% - 应用入口
- `app/core/database.py`: 58% - 数据库配置
- `app/api/routes/messages.py`: 65% - 消息路由
- `app/services/user_service.py`: 66% - 用户服务
- `app/api/routes/knowledge.py`: 68% - 知识库路由
- `app/error_handlers.py`: 68% - 错误处理
- `app/api/routes/users.py`: 73% - 用户路由
- `app/file_upload.py`: 74% - 文件上传
- `app/api/routes/admin.py`: 75% - 管理员路由
- `app/api/routes/persona.py`: 75% - 人设卡路由
- `app/core/security.py`: 77% - 安全功能
- `app/api/deps.py`: 77% - 依赖注入
- `app/services/knowledge_service.py`: 78% - 知识库服务

## 测试配置和 Fixtures

测试配置位于 `tests/conftest.py`，提供了常用的 fixtures：

### 数据库 Fixtures

```python
@pytest.fixture(scope="function")
def test_db() -> Session:
    """提供测试数据库会话，自动清理"""
    session = TestingSessionLocal()
    yield session
    
    # 测试结束后清理所有数据（按外键依赖顺序）
    session.query(CommentReaction).delete()
    session.query(Comment).delete()
    # ... 其他表 ...
    session.commit()
    session.close()
```

### 用户 Fixtures

```python
@pytest.fixture
def test_user(test_db: Session) -> User:
    """创建普通测试用户"""
    factory = TestDataFactory(test_db)
    return factory.create_user()

@pytest.fixture
def admin_user(test_db: Session) -> User:
    """创建管理员用户"""
    factory = TestDataFactory(test_db)
    return factory.create_admin_user()

@pytest.fixture
def moderator_user(test_db: Session) -> User:
    """创建审核员用户"""
    factory = TestDataFactory(test_db)
    return factory.create_moderator_user()
```

### 客户端 Fixtures

```python
@pytest.fixture
def client() -> TestClient:
    """未认证的测试客户端"""
    from fastapi.testclient import TestClient
    from app.main import app
    return TestClient(app)

@pytest.fixture
def authenticated_client(test_user: User) -> TestClient:
    """已认证的测试客户端"""
    client = TestClient(app)
    # 登录并设置认证头
    response = client.post("/api/auth/token", json={
        "username": test_user.username,
        "password": "password123"
    })
    token = response.json()["access_token"]
    client.headers["Authorization"] = f"Bearer {token}"
    return client

@pytest.fixture
def admin_client(admin_user: User) -> TestClient:
    """管理员测试客户端"""
    # 类似 authenticated_client，但使用管理员用户
    ...
```

### 工厂 Fixture

```python
@pytest.fixture
def factory(test_db: Session) -> TestDataFactory:
    """测试数据工厂实例"""
    return TestDataFactory(test_db)
```

## 测试类型

### 1. 单元测试 (Unit Tests)

单元测试专注于测试单个函数、类或方法的功能，使用 mock 隔离外部依赖。

**位置**: `tests/unit/`

**示例**：测试服务层方法

```python
# tests/unit/services/test_user_service.py
import pytest
from app.services.user_service import UserService

class TestUserRetrieval:
    """Test user retrieval methods"""
    
    def test_get_user_by_id_success(self):
        """Test getting user by ID successfully"""
        db = MagicMock()
        service = UserService(db)
        
        # Mock database query
        mock_user = User(id=1, username="testuser", email="test@example.com")
        db.query().filter().first.return_value = mock_user
        
        # Execute
        user = service.get_user_by_id(1)
        
        # Verify
        assert user == mock_user
        assert user.username == "testuser"
```

### 2. 集成测试 (Integration Tests)

集成测试测试完整的 API 端点流程，包括请求验证、业务逻辑和响应格式化。

**位置**: `tests/integration/routes/`

**示例**：测试 API 端点

```python
# tests/integration/routes/test_auth_routes.py
class TestLogin:
    """Test POST /api/auth/token endpoint (login)"""
    
    def test_login_with_valid_credentials_json(self, test_db: Session):
        """Test login with valid credentials using JSON format"""
        # Create test user
        factory = TestDataFactory(test_db)
        user = factory.create_user(
            username="testuser",
            email="test@example.com",
            password="password123"
        )
        
        # Login
        response = client.post(
            "/api/auth/token",
            json={
                "username": "testuser",
                "password": "password123"
            }
        )
        
        # Verify
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert "refresh_token" in data
        assert data["token_type"] == "bearer"
```

### 3. 属性测试 (Property-Based Tests)

属性测试使用 Hypothesis 库生成随机输入，验证系统在各种输入下的通用属性。

**位置**: `tests/property/`

**示例**：测试认证一致性

```python
# tests/property/test_auth_route_properties.py
from hypothesis import given, strategies as st

class TestAuthenticationConsistency:
    """Test authentication consistency across all protected endpoints
    
    **Validates: Requirements 3.8**
    """
    
    @pytest.mark.parametrize("method,endpoint", [
        ("GET", "/api/users/me"),
        ("PUT", "/api/users/me/password"),
        ("DELETE", "/api/knowledge/{kb_id}"),
    ])
    def test_unauthenticated_access_returns_401(self, method, endpoint):
        """Test that all protected endpoints return 401 for unauthenticated requests"""
        response = client.request(method, endpoint)
        assert response.status_code == 401
```

### 4. 端到端测试 (E2E Tests)

端到端测试验证完整的用户流程，从开始到结束。

**位置**: `tests/e2e/`

**示例**：测试用户注册流程

```python
# tests/e2e/test_user_registration_flow.py
def test_complete_user_registration_flow(test_db: Session):
    """Test complete user registration flow: send code → register → login"""
    
    # Step 1: Send verification code
    response = client.post("/api/auth/send-verification-code", 
                          json={"email": "newuser@example.com"})
    assert response.status_code == 200
    
    # Step 2: Register user
    response = client.post("/api/auth/register", json={
        "username": "newuser",
        "email": "newuser@example.com",
        "password": "password123",
        "verification_code": "123456"
    })
    assert response.status_code == 200
    
    # Step 3: Login
    response = client.post("/api/auth/token", json={
        "username": "newuser",
        "password": "password123"
    })
    assert response.status_code == 200
    assert "access_token" in response.json()
```

### 5. 测试数据工厂 (TestDataFactory)

使用 TestDataFactory 创建一致的测试数据：

```python
# tests/test_data_factory.py
class TestDataFactory:
    """Factory for creating test data"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def create_user(self, **kwargs) -> User:
        """Create a test user with unique username and email"""
        defaults = {
            "username": f"user_{uuid.uuid4().hex[:8]}",
            "email": f"test_{uuid.uuid4().hex[:8]}@example.com",
            "password": "password123",
            "is_active": True
        }
        defaults.update(kwargs)
        
        service = UserService(self.db)
        return service.create_user(**defaults)
    
    def create_knowledge_base(self, uploader: User, **kwargs) -> KnowledgeBase:
        """Create a test knowledge base"""
        defaults = {
            "name": f"KB_{uuid.uuid4().hex[:8]}",
            "description": "Test knowledge base",
            "copyright_owner": uploader.username
        }
        defaults.update(kwargs)
        
        service = KnowledgeService(self.db)
        return service.create_knowledge_base(uploader_id=uploader.id, **defaults)
```

## 测试质量报告

### 测试套件质量评分：8.5/10 (优秀)

基于最新的测试质量验证报告，测试套件在以下方面表现优秀：

#### ✅ 优点

1. **完整的测试文档** (9.5/10)
   - 100% 的测试文件有模块级文档字符串
   - 100% 的测试类有类文档字符串
   - 95%+ 的测试函数有描述性文档字符串
   - 85.7% 的测试文件引用了需求编号

2. **清晰的错误消息** (9.0/10)
   - 使用统一的断言辅助函数 (`assert_error_response`, `assert_success_response`)
   - 错误消息包含期望值、实际值和上下文信息
   - 测试失败时提供足够的调试信息

3. **优秀的测试隔离** (9.5/10)
   - 每个测试使用独立的数据库会话
   - 测试结束后自动清理所有数据
   - 使用 UUID 生成唯一标识符避免冲突
   - 测试可以独立运行，顺序不影响结果

4. **高测试覆盖率**
   - 1366 个测试 (1355 通过，10 失败，1 跳过)
   - 79% 的代码覆盖率
   - 覆盖单元测试、集成测试、属性测试和 E2E 测试

5. **良好的需求追溯性** (9.0/10)
   - 测试文档中引用需求编号
   - 属性测试使用 `**Validates: Requirements X.Y**` 格式
   - 便于追踪需求实现情况

#### ⚠️ 需要改进

1. **测试执行时间** (5.0/10)
   - 当前：451 秒 (7分31秒)
   - 目标：60 秒
   - 建议：使用 `pytest-xdist` 并行执行

2. **失败的测试** (10 个)
   - 5 个 deps 测试失败 (依赖注入相关)
   - 5 个 error_handlers 测试失败 (错误处理相关)
   - 需要修复这些测试的 mock 配置或测试逻辑

3. **TestDataFactory 警告**
   - pytest 误认为 TestDataFactory 是测试类
   - 建议重命名为 `DataFactory` 或添加 `__test__ = False`

### 测试文档示例

**优秀的测试文档示例**：

```python
"""
Integration tests for auth routes
Tests login, token refresh, email verification, password reset, rate limiting, and account lockout

Requirements: 1.8, 2.1, 7.1, 7.2
"""

class TestLogin:
    """Test POST /api/auth/token endpoint (login)"""
    
    def test_login_with_valid_credentials_json(self, test_db: Session):
        """Test login with valid credentials using JSON format
        
        Verifies:
        - User can login with correct username and password
        - Response includes access_token and refresh_token
        - Token type is "bearer"
        """
        # Test implementation
```

## 测试最佳实践

### 1. 测试命名约定

遵循清晰的命名约定，使测试意图一目了然：

**测试文件命名**：
- 单元测试：`test_<module_name>.py`
- 集成测试：`test_<feature>_routes.py`
- 属性测试：`test_<property_name>.py`
- E2E 测试：`test_<workflow>_flow.py`

**测试类命名**：
- `Test<Feature>` - 例如：`TestUserAuthentication`
- `Test<HTTPMethod><Endpoint>` - 例如：`TestGetUserProfile`

**测试函数命名**：
- `test_<action>_<expected_result>` - 例如：`test_login_succeeds`
- `test_<action>_<condition>_<expected_result>` - 例如：`test_login_with_invalid_password_fails`

```python
# ✅ 好的命名
def test_create_user_with_valid_data_succeeds():
    pass

def test_create_user_with_duplicate_username_returns_400():
    pass

def test_login_with_invalid_password_fails():
    pass

# ❌ 不好的命名
def test_user():
    pass

def test_1():
    pass

def test_function():
    pass
```

### 2. 测试隔离和数据清理

确保每个测试独立运行，不受其他测试影响：

**数据库隔离**：
```python
@pytest.fixture(scope="function")
def test_db() -> Session:
    """Create a test database session with automatic cleanup"""
    session = TestingSessionLocal()
    
    yield session
    
    # Clean up all data after test (in reverse order of foreign key dependencies)
    session.query(CommentReaction).delete()
    session.query(Comment).delete()
    session.query(DownloadRecord).delete()
    session.query(UploadRecord).delete()
    session.query(EmailVerification).delete()
    session.query(StarRecord).delete()
    session.query(Message).delete()
    session.query(PersonaCardFile).delete()
    session.query(PersonaCard).delete()
    session.query(KnowledgeBaseFile).delete()
    session.query(KnowledgeBase).delete()
    session.query(User).delete()
    session.commit()
    session.close()
```

**使用 TestDataFactory 创建唯一数据**：
```python
def create_user(self, **kwargs) -> User:
    """Create test user with unique identifiers"""
    defaults = {
        "username": f"user_{uuid.uuid4().hex[:8]}",  # 唯一用户名
        "email": f"test_{uuid.uuid4().hex[:8]}@example.com",  # 唯一邮箱
        "password": "password123",
        "is_active": True
    }
    defaults.update(kwargs)
    return service.create_user(**defaults)
```

### 3. 使用断言辅助函数

使用统一的断言辅助函数确保错误消息的一致性和清晰性：

**验证错误响应**：
```python
from tests.helpers.assertions import assert_error_response

def test_login_with_invalid_password(test_db: Session):
    """Test login with invalid password returns error"""
    # ... create user and attempt login ...
    
    # Use helper function for consistent error checking
    assert_error_response(
        response,
        expected_status_codes=[400, 401],
        expected_message_keywords=["password", "incorrect", "invalid"]
    )
```

**验证成功响应**：
```python
from tests.helpers.assertions import assert_success_response

def test_get_user_profile(authenticated_client):
    """Test getting user profile"""
    response = authenticated_client.get("/api/users/me")
    
    # Verify success and get data
    data = assert_success_response(response, expected_status=200)
    assert "username" in data
    assert "email" in data
```

**验证分页响应**：
```python
from tests.helpers.assertions import assert_pagination_response

def test_list_knowledge_bases(authenticated_client):
    """Test listing knowledge bases with pagination"""
    response = authenticated_client.get("/api/knowledge/public?page=1&page_size=10")
    
    # Verify pagination format
    data = assert_pagination_response(response, expected_page=1, expected_page_size=10)
    assert "items" in data
```

### 4. 使用 Mock 隔离外部依赖

对于外部依赖（如邮件服务、文件系统），使用 mock 进行隔离：

**Mock 邮件服务**：
```python
from unittest.mock import patch, MagicMock

def test_send_verification_email(test_db: Session):
    """Test sending verification email"""
    with patch('app.services.email_service.EmailService.send_email') as mock_send:
        mock_send.return_value = True
        
        # Test code
        service = AuthService(test_db)
        result = service.send_verification_code("test@example.com")
        
        # Verify
        assert result is True
        mock_send.assert_called_once()
```

**Mock 文件系统操作**：
```python
@patch('os.path.exists')
@patch('os.remove')
def test_delete_file(mock_remove, mock_exists, test_db: Session):
    """Test file deletion"""
    mock_exists.return_value = True
    
    # Test code
    service = FileService(test_db)
    service.delete_file("test.txt")
    
    # Verify
    mock_remove.assert_called_once_with("test.txt")
```

### 5. Monkeypatch 最佳实践

**Monkeypatch** 是 pytest 提供的内置 fixture，用于在测试期间临时修改对象、字典、环境变量等。在并行测试环境中，正确使用 monkeypatch 对于避免测试间的状态泄漏至关重要。

#### 为什么使用 Monkeypatch？

- **自动清理**：测试结束后自动恢复原始值，无需手动清理
- **测试隔离**：确保修改只影响当前测试，不泄漏到其他测试
- **并行安全**：在 pytest-xdist 并行执行时保持隔离

#### 基本用法

**修改类或模块属性**：
```python
def test_query_exception(admin_client, test_db, monkeypatch):
    """Test exception handling in database query"""
    from sqlalchemy.orm import Query
    
    # Mock Query.scalar to raise an exception
    def mock_scalar_error(self):
        raise Exception("Database error")
    
    monkeypatch.setattr(Query, "scalar", mock_scalar_error)
    
    # Test code - monkeypatch automatically restores original after test
    response = admin_client.get("/api/admin/stats")
    assert response.status_code == 500
```

**修改环境变量**：
```python
def test_with_custom_env(monkeypatch):
    """Test with custom environment variable"""
    monkeypatch.setenv("API_KEY", "test-key-123")
    
    # Test code using the environment variable
    assert os.getenv("API_KEY") == "test-key-123"
    # Automatically restored after test
```

**修改字典**：
```python
def test_with_custom_config(monkeypatch):
    """Test with custom configuration"""
    from app.core import config
    
    monkeypatch.setitem(config.SETTINGS, "MAX_UPLOAD_SIZE", 1024)
    
    # Test code using the modified config
    assert config.SETTINGS["MAX_UPLOAD_SIZE"] == 1024
```

**删除属性或字典项**：
```python
def test_without_optional_feature(monkeypatch):
    """Test behavior when optional feature is not available"""
    import sys
    
    monkeypatch.delattr("sys.stdout", raising=False)
    # Test code
```

#### 关键原则

**✅ 正确做法**：

1. **始终使用函数级别的 monkeypatch fixture**：
```python
# ✅ 正确：monkeypatch 作为测试函数参数
def test_something(test_db, monkeypatch):
    monkeypatch.setattr(Query, "count", mock_count)
    # Test code
```

2. **依赖 pytest 的自动清理**：
```python
# ✅ 正确：无需手动清理
def test_query_error(admin_client, monkeypatch):
    from sqlalchemy.orm import Query
    
    def mock_error(self):
        raise Exception("Error")
    
    monkeypatch.setattr(Query, "scalar", mock_error)
    
    response = admin_client.get("/api/admin/stats")
    assert response.status_code == 500
    # monkeypatch 自动恢复原始方法
```

3. **在需要保留原始行为时使用包装函数**：
```python
# ✅ 正确：选择性地调用原始方法
def test_conditional_mock(test_db, monkeypatch):
    from sqlalchemy.orm import Session
    
    original_commit = Session.commit
    call_count = [0]
    
    def mock_commit(self):
        call_count[0] += 1
        if call_count[0] > 2:  # 前两次正常，第三次失败
            raise Exception("Commit failed")
        return original_commit(self)
    
    monkeypatch.setattr(Session, "commit", mock_commit)
    # Test code
```

**❌ 错误做法**：

1. **不要在模块级别或类级别使用 monkeypatch**：
```python
# ❌ 错误：不要在 fixture 中使用 session 或 module scope
@pytest.fixture(scope="session")  # 错误的 scope
def global_mock(monkeypatch):
    monkeypatch.setattr(...)  # 会影响所有测试
```

2. **不要手动恢复（除非有特殊原因）**：
```python
# ❌ 不推荐：手动清理是多余的
def test_something(monkeypatch):
    original = Query.scalar
    monkeypatch.setattr(Query, "scalar", mock_scalar)
    
    try:
        # Test code
        pass
    finally:
        monkeypatch.setattr(Query, "scalar", original)  # 多余
```

3. **不要修改全局状态而不使用 monkeypatch**：
```python
# ❌ 错误：直接修改全局状态
def test_bad_practice():
    original = Query.scalar
    Query.scalar = mock_scalar  # 可能泄漏到其他并行测试
    
    try:
        # Test code
        pass
    finally:
        Query.scalar = original  # 在并行测试中不可靠
```

#### 并行测试中的 Monkeypatch 隔离

在使用 `pytest-xdist` 并行执行测试时，monkeypatch 的隔离特性尤为重要：

**为什么 monkeypatch 在并行测试中是安全的**：
- 每个 worker 进程有独立的内存空间
- monkeypatch 修改只影响当前 worker 的当前测试
- 测试结束后自动恢复，不影响同一 worker 的后续测试

**示例：并行安全的测试**：
```python
# 这些测试可以安全地并行运行
def test_scenario_a(admin_client, monkeypatch):
    """Test scenario A with mocked database error"""
    from sqlalchemy.orm import Query
    
    def mock_error(self):
        raise Exception("Error A")
    
    monkeypatch.setattr(Query, "count", mock_error)
    response = admin_client.get("/api/admin/users")
    assert response.status_code == 500

def test_scenario_b(admin_client, monkeypatch):
    """Test scenario B with different mocked error"""
    from sqlalchemy.orm import Query
    
    def mock_error(self):
        raise Exception("Error B")
    
    monkeypatch.setattr(Query, "count", mock_error)
    response = admin_client.get("/api/admin/users")
    assert response.status_code == 500
```

#### 常见用例

**1. 模拟数据库错误**：
```python
def test_db_commit_failure(admin_client, factory, test_db, monkeypatch):
    """Test handling of database commit failure"""
    from sqlalchemy.orm import Session
    
    user = factory.create_user()
    
    original_commit = Session.commit
    commit_count = [0]
    
    def mock_commit_error(self):
        commit_count[0] += 1
        if commit_count[0] > 2:  # 跳过认证相关的 commit
            raise Exception("Database commit failed")
        return original_commit(self)
    
    monkeypatch.setattr(Session, "commit", mock_commit_error)
    
    response = admin_client.delete(f"/api/admin/users/{user.id}")
    assert response.status_code == 500
    assert "删除用户失败" in response.json()["detail"]
```

**2. 模拟外部服务失败**：
```python
def test_notification_failure(admin_client, factory, test_db, monkeypatch):
    """Test handling of notification service failure"""
    from app.models.database import Message
    
    user = factory.create_user()
    
    original_init = Message.__init__
    
    def mock_init_error(self, **kwargs):
        raise Exception("Failed to create message")
    
    monkeypatch.setattr(Message, "__init__", mock_init_error)
    
    # 操作应该成功，但通知失败只记录警告
    response = admin_client.post(f"/api/admin/users/{user.id}/mute")
    assert response.status_code == 200
```

**3. 测试环境变量配置**：
```python
def test_with_debug_mode(monkeypatch):
    """Test behavior in debug mode"""
    monkeypatch.setenv("DEBUG", "true")
    
    from app.core.config import settings
    settings.reload()  # 重新加载配置
    
    # Test debug-specific behavior
    assert settings.DEBUG is True
```

#### 调试技巧

如果怀疑 monkeypatch 相关的问题：

1. **验证修改生效**：
```python
def test_verify_mock(monkeypatch):
    from sqlalchemy.orm import Query
    
    original = Query.count
    monkeypatch.setattr(Query, "count", lambda self: 42)
    
    # 验证修改生效
    assert Query.count is not original
    assert Query.count(None) == 42
```

2. **单独运行测试**：
```bash
# 如果测试在并行时失败，尝试单独运行
pytest tests/integration/routes/test_admin_routes.py::TestClass::test_method -v
```

3. **检查清理**：
```python
def test_cleanup_verification(monkeypatch):
    from sqlalchemy.orm import Query
    
    original = Query.count
    monkeypatch.setattr(Query, "count", lambda self: 42)
    
    # 测试代码
    
    # 在测试结束时，pytest 会自动恢复
    # 可以在下一个测试中验证
```

#### 总结

- ✅ 始终使用函数级别的 `monkeypatch` fixture
- ✅ 依赖 pytest 的自动清理机制
- ✅ 在并行测试中放心使用 monkeypatch
- ❌ 不要在 session 或 module scope 的 fixture 中使用
- ❌ 不要手动修改全局状态而不使用 monkeypatch
- ❌ 不要过度使用 try-finally 手动清理（monkeypatch 会自动处理）

### 6. 测试边界条件

- 测试正常情况
- 测试边界值
- 测试异常情况

```python
def test_create_user_with_empty_username():
    """测试空用户名"""
    with pytest.raises(ValueError):
        service.create_user(username="", email="test@example.com", password="pass")

def test_create_user_with_short_password():
    """测试过短的密码"""
    with pytest.raises(ValueError):
        service.create_user(username="user", email="test@example.com", password="123")

def test_create_user_with_invalid_email():
    """测试无效的邮箱"""
    with pytest.raises(ValueError):
        service.create_user(username="user", email="invalid", password="password")
```

## 测试工具和辅助函数

### 断言辅助函数

项目提供了统一的断言辅助函数，位于 `tests/helpers/assertions.py` 和 `tests/conftest.py`：

#### assert_error_response()

验证错误响应格式和内容：

```python
def assert_error_response(
    response: Response,
    expected_status_codes: Union[int, List[int]],
    expected_message_keywords: Union[str, List[str]]
) -> None:
    """Verify error response format and content
    
    Args:
        response: FastAPI test client response
        expected_status_codes: Expected HTTP status code(s)
        expected_message_keywords: Keywords that should appear in error message
    """
```

**使用示例**：
```python
assert_error_response(
    response,
    expected_status_codes=[400, 401],
    expected_message_keywords=["password", "incorrect"]
)
```

#### assert_success_response()

验证成功响应并返回数据：

```python
def assert_success_response(
    response: Response,
    expected_status: int = 200,
    expected_message: Optional[str] = None
) -> dict:
    """Verify success response and return data
    
    Args:
        response: FastAPI test client response
        expected_status: Expected HTTP status code (default: 200)
        expected_message: Optional expected message
        
    Returns:
        Response data dictionary
    """
```

**使用示例**：
```python
data = assert_success_response(response, expected_status=200)
assert "username" in data
```

#### assert_pagination_response()

验证分页响应格式：

```python
def assert_pagination_response(
    response: Response,
    expected_page: int,
    expected_page_size: int,
    min_total: int = 0
) -> dict:
    """Verify pagination response format
    
    Args:
        response: FastAPI test client response
        expected_page: Expected page number
        expected_page_size: Expected page size
        min_total: Minimum expected total count
        
    Returns:
        Response data dictionary
    """
```

**使用示例**：
```python
data = assert_pagination_response(response, expected_page=1, expected_page_size=10)
assert len(data["items"]) <= 10
```

### TestDataFactory

测试数据工厂类，用于创建一致的测试数据，位于 `tests/test_data_factory.py`：

```python
class TestDataFactory:
    """Factory for creating test data with unique identifiers"""
    
    def __init__(self, db: Session):
        self.db = db
    
    # 用户创建
    def create_user(self, **kwargs) -> User
    def create_admin_user(self, **kwargs) -> User
    def create_moderator_user(self, **kwargs) -> User
    
    # 内容创建
    def create_knowledge_base(self, uploader: User, **kwargs) -> KnowledgeBase
    def create_persona_card(self, uploader: User, **kwargs) -> PersonaCard
    def create_message(self, sender: User, recipient: User, **kwargs) -> Message
    def create_comment(self, author: User, **kwargs) -> Comment
```

**使用示例**：
```python
def test_example(test_db: Session):
    factory = TestDataFactory(test_db)
    
    # 创建测试用户
    user = factory.create_user(username="testuser")
    
    # 创建测试知识库
    kb = factory.create_knowledge_base(uploader=user, name="Test KB")
    
    # 执行测试
    assert kb.uploader_id == user.id
```

## 持续集成

### GitHub Actions

项目使用 GitHub Actions 进行持续集成，配置文件位于 `.github/workflows/test.yml`：

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.8
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      - name: Run tests
        run: |
          pytest tests/ --cov=app --cov-report=xml
      - name: Upload coverage
        uses: codecov/codecov-action@v2
```

## API文档

### 在线文档

启动服务器后，可以通过以下地址访问交互式API文档：

- **Swagger UI**: `http://localhost:9278/docs`  
  提供交互式 API 测试界面，可以直接在浏览器中测试所有接口
  
- **ReDoc**: `http://localhost:9278/redoc`  
  提供更友好的 API 文档阅读界面

### Postman集合

我们提供了Postman集合文件，方便测试API：

1. 安装Postman
2. 导入 `docs/MaiMNP_API.postman_collection.json`
3. 设置环境变量：
   - `baseUrl`: API基础URL (默认: http://localhost:9278)
   - `token`: 登录后获取的JWT令牌
   - `kb_id`: 知识库ID
   - `user_id`: 用户ID

### API文档

详细的API文档请参考：
- [API.md](./API.md) - 完整的 API 接口文档
- [ARCHITECTURE.md](./ARCHITECTURE.md) - 架构设计文档

## 开发环境设置

### 1. 安装依赖

```bash
pip install -r requirements.txt
```

主要依赖：
- `fastapi`: Web 框架
- `uvicorn`: ASGI 服务器
- `sqlalchemy`: ORM 框架
- `pydantic`: 数据验证
- `pydantic-settings`: 配置管理
- `pytest`: 测试框架
- `pytest-cov`: 覆盖率工具

### 2. 设置环境变量

创建 `.env` 文件：

```bash
cp .env.template .env
```

必须配置的关键项：
```env
# JWT 配置
JWT_SECRET_KEY=your-secret-key-here
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=15

# 数据库配置
DATABASE_URL=sqlite:///./data/maimnp.db

# 邮件配置
MAIL_HOST=smtp.qq.com
MAIL_PORT=465
MAIL_USER=your_email@qq.com
MAIL_PWD=your_email_authorization_code

# 管理员配置
SUPERADMIN_USERNAME=superadmin
SUPERADMIN_PWD=admin123456
HIGHEST_PASSWORD=your_highest_password

# 外部域名
EXTERNAL_DOMAIN=example.com
```

### 3. 初始化数据库

```bash
# 创建数据库并执行迁移
alembic upgrade head
```

### 4. 启动服务器

```bash
# 开发模式（自动重载）
./start_backend.sh

# 或使用 uvicorn 直接启动
python -m uvicorn app.main:app --host 0.0.0.0 --port 9278 --reload
```

## 代码规范

项目遵循以下代码规范：

### 1. 导入规范

- 使用绝对导入（从 `app` 开始）
- 避免循环依赖
- 按标准库、第三方库、本地模块的顺序组织导入

```python
# 标准库
from typing import Optional, List
from datetime import datetime

# 第三方库
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

# 本地模块
from app.core.database import get_db
from app.services.user_service import UserService
from app.models.schemas import UserResponse
```

### 2. 类型注解

- 所有函数参数和返回值都应该有类型注解
- 使用 `typing` 模块提供的类型

```python
from typing import Optional, List

def get_users(
    db: Session,
    skip: int = 0,
    limit: int = 100
) -> List[User]:
    return db.query(User).offset(skip).limit(limit).all()
```

### 3. 文档字符串

- 所有公共函数都应该有 docstring
- 使用 Google 风格的 docstring

```python
def create_user(username: str, email: str, password: str) -> User:
    """创建新用户
    
    Args:
        username: 用户名
        email: 邮箱地址
        password: 密码（明文）
    
    Returns:
        创建的用户对象
    
    Raises:
        ValueError: 用户名或邮箱已存在
    """
    pass
```

### 4. 代码格式化

使用 Black 进行代码格式化：

```bash
# 格式化所有代码
black .

# 检查代码格式
black --check .
```

### 5. 代码检查

使用 flake8 进行代码检查：

```bash
# 检查代码
flake8 .

# 忽略特定错误
flake8 --ignore=E501,W503 .
```

### 6. 类型检查

使用 mypy 进行类型检查：

```bash
# 类型检查
mypy app/

# 严格模式
mypy --strict app/
```

## 贡献指南

### 1. 开发流程

1. Fork 项目
2. 创建功能分支 (`git checkout -b feature/amazing-feature`)
3. 提交更改 (`git commit -m 'Add some amazing feature'`)
4. 推送到分支 (`git push origin feature/amazing-feature`)
5. 创建 Pull Request

### 2. 提交规范

使用语义化的提交信息：

- `feat`: 新功能
- `fix`: 修复 bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建或辅助工具的变动

示例：
```
feat: 添加用户头像上传功能
fix: 修复知识库下载时的文件名编码问题
docs: 更新 API 文档
test: 添加用户服务的单元测试
```

### 3. Pull Request 要求

- 确保所有测试通过
- 添加适当的测试用例
- 更新相关文档
- 代码符合项目规范
- 提供清晰的 PR 描述

## 常见问题

### Q: 测试数据库如何隔离？

A: 使用 pytest fixtures 创建独立的测试数据库会话，每个测试结束后清理所有数据：

```python
@pytest.fixture(scope="function")
def test_db() -> Session:
    session = TestingSessionLocal()
    yield session
    
    # 按外键依赖顺序删除数据
    session.query(CommentReaction).delete()
    session.query(Comment).delete()
    # ... 其他表 ...
    session.commit()
    session.close()
```

### Q: 如何测试需要认证的接口？

A: 使用 `authenticated_client` fixture 创建已认证的客户端：

```python
def test_get_user_profile(authenticated_client):
    """Test getting user profile"""
    response = authenticated_client.get("/api/users/me")
    assert response.status_code == 200
```

或手动创建认证头：

```python
@pytest.fixture
def auth_headers(test_user):
    response = client.post("/api/auth/token", json={
        "username": test_user.username,
        "password": "password123"
    })
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}
```

### Q: 如何测试文件上传？

A: 使用 TestClient 的 files 参数：

```python
def test_upload_file(authenticated_client):
    files = {"file": ("test.txt", b"test content", "text/plain")}
    data = {"name": "Test", "description": "Test description"}
    
    response = authenticated_client.post(
        "/api/knowledge/upload",
        files=files,
        data=data
    )
    assert response.status_code == 200
```

### Q: 如何 mock 外部服务？

A: 使用 `unittest.mock` 或 `pytest-mock`：

```python
from unittest.mock import patch

def test_send_email(test_db: Session):
    with patch('app.services.email_service.EmailService.send_email') as mock_send:
        mock_send.return_value = True
        
        # 测试代码
        service = AuthService(test_db)
        result = service.send_verification_code("test@example.com")
        
        # 验证
        assert result is True
        mock_send.assert_called_once()
```

### Q: 如何加速测试执行？

A: 使用 `pytest-xdist` 并行执行测试：

```bash
# 使用所有 CPU 核心
pytest -n auto

# 使用指定数量的进程
pytest -n 4
```

当前测试执行时间：162 秒（目标：60 秒）

### Q: 如何只运行失败的测试？

A: 使用 `--lf` (last failed) 选项：

```bash
# 只运行上次失败的测试
pytest --lf

# 先运行失败的测试，再运行其他测试
pytest --ff
```

### Q: 如何查看测试覆盖率？

A: 生成 HTML 覆盖率报告：

```bash
# 生成报告
pytest --cov=app --cov-report=html

# 查看报告
open htmlcov/index.html  # macOS
xdg-open htmlcov/index.html  # Linux
```

### Q: TestDataFactory 警告如何解决？

A: pytest 误认为 `TestDataFactory` 是测试类。解决方法：

1. 重命名为 `DataFactory`
2. 或添加 `__test__ = False` 属性：

```python
class TestDataFactory:
    __test__ = False  # 告诉 pytest 这不是测试类
    
    def __init__(self, db: Session):
        self.db = db
```

## 改进建议

基于测试质量报告，以下是改进建议：

### 高优先级

1. **修复失败的测试** (10个)
   - 修复 5 个 deps 测试（依赖注入相关）
   - 修复 5 个 error_handlers 测试（错误处理相关）
   - 这些测试可能需要更新 mock 配置或测试逻辑

2. **优化测试执行时间**
   - 启用 `pytest-xdist` 并行执行
   - 目标：从 451 秒降低到 60 秒以内
   - 当前瓶颈：集成测试和数据库操作

3. **解决 TestDataFactory 警告**
   - 重命名为 `DataFactory` 或添加 `__test__ = False`

### 中优先级

1. **提高低覆盖率模块的测试覆盖率**
   - `app/utils/file.py`: 22% → 90%
   - `app/utils/websocket.py`: 43% → 90%
   - `app/main.py`: 52% → 90%
   - `app/core/database.py`: 58% → 90%

2. **增强错误消息**
   - 为所有断言添加描述性消息
   - 统一使用断言辅助函数

3. **补充缺失的文档**
   - 为少数缺少文档字符串的测试函数添加文档

### 低优先级

1. **添加测试标记**
   - 使用 `@pytest.mark.slow` 标记慢速测试
   - 使用 `@pytest.mark.integration` 标记集成测试
   - 使用 `@pytest.mark.unit` 标记单元测试

2. **改进测试组织**
   - 考虑将相关测试分组
   - 添加更多的测试类来组织测试

## 相关文档

- [API 文档](./API.md) - 完整的 API 接口文档
- [架构文档](./ARCHITECTURE.md) - 项目架构和设计说明
- [README.md](../README.md) - 项目概述和快速开始

---

**文档版本**: 3.1  
**最后更新**: 2025-02-20  
**维护者**: 开发团队  
**测试覆盖率**: 79% (1366 个测试)  
**测试质量评分**: 8.5/10 (优秀)