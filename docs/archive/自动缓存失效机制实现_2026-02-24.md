# 自动缓存失效机制实现

**日期**: 2026-02-24  
**版本**: 2.2.0

## 概述

实现了通用的自动缓存失效机制，在数据更新时自动清除相关缓存，解决了测试中缓存导致的数据不一致问题。

## 问题背景

在之前的测试中，由于 HTTP 缓存中间件会缓存 GET 请求响应（默认 TTL 300秒），即使数据库数据被删除，API 仍返回缓存的旧数据，导致测试失败。

## 实现方案

### 1. 通用缓存失效模块

创建了 `app/core/cache/invalidation.py` 模块，提供：

#### 核心函数

- `invalidate_cache_sync()`: 通用的同步缓存失效函数
- `_async_invalidate_pattern()`: 异步清除缓存模式的内部辅助函数

#### 业务特定函数

- `invalidate_persona_cache()`: 清除人设卡相关缓存
- `invalidate_knowledge_cache()`: 清除知识库相关缓存
- `invalidate_user_cache()`: 清除用户相关缓存
- `invalidate_message_cache()`: 清除消息相关缓存
- `invalidate_comment_cache()`: 清除评论相关缓存

### 2. 业务代码集成

#### 人设卡服务 (PersonaService)

在以下方法中添加了缓存失效调用：

- `save_persona_card()`: 保存/创建人设卡后清除缓存
- `update_persona_card()`: 更新人设卡后清除缓存
- `delete_persona_card()`: 删除人设卡后清除缓存
- `add_star()`: 收藏人设卡后清除缓存（因为 star_count 变化）
- `remove_star()`: 取消收藏后清除缓存

#### 知识库服务 (KnowledgeService)

在以下方法中添加了缓存失效调用：

- `save_knowledge_base()`: 保存/创建知识库后清除缓存
- `update_knowledge_base()`: 更新知识库后清除缓存
- `delete_knowledge_base()`: 删除知识库后清除缓存
- `add_star()`: 收藏知识库后清除缓存
- `remove_star()`: 取消收藏后清除缓存

#### 文件上传服务 (FileUploadService)

- `upload_persona_card()`: 上传人设卡后清除缓存

### 3. 缓存模式

#### 人设卡

- `maimnp:http:*persona/public*`: 所有公开人设卡列表的缓存
- `maimnp:http:*persona/{pc_id}*`: 特定人设卡详情的缓存

#### 知识库

- `maimnp:kb:public:*`: 公开知识库列表的缓存
- `maimnp:http:*knowledge/{kb_id}*`: 特定知识库详情的缓存
- `maimnp:kb:user:{uploader_id}:*`: 用户知识库列表的缓存

#### 用户

- `maimnp:http:*users/{user_id}*`: 用户详情的缓存
- `user:{user_id}`: 用户数据的缓存

#### 消息

- `maimnp:http:*messages/{message_id}*`: 消息详情的缓存
- `maimnp:http:*messages*user_id={user_id}*`: 用户消息列表的缓存

#### 评论

- `maimnp:http:*comments/{comment_id}*`: 评论详情的缓存
- `maimnp:http:*comments*target_id={target_id}*`: 目标评论列表的缓存

## 技术细节

### 事件循环处理

为避免 "Cannot run the event loop while another loop is running" 错误，实现了智能事件循环检测：

```python
try:
    loop = asyncio.get_running_loop()
    # 如果已经在事件循环中，使用 create_task 异步执行
    for pattern in patterns:
        asyncio.create_task(_async_invalidate_pattern(cache_manager, pattern))
except RuntimeError:
    # 没有运行的事件循环，创建新的
    loop = asyncio.new_event_loop()
    # ...
```

### 错误处理

- 缓存失效失败不会影响业务逻辑执行
- 所有异常都会被捕获并记录日志
- 使用 `try-except` 包裹缓存操作，确保业务代码健壮性

### 通用性设计

- 核心函数 `invalidate_cache_sync()` 接受缓存模式列表，可用于任何业务场景
- 业务特定函数封装了各业务的缓存模式，简化调用
- 支持同步和异步环境，自动检测并适配

## 测试结果

- 所有 67 个人设卡相关测试通过 ✅
- 无需在测试中手动添加 `Cache-Control: no-cache` 头
- 缓存失效机制自动工作，数据一致性得到保证

## 使用示例

### 在服务中使用

```python
from app.core.cache.factory import get_cache_manager
from app.core.cache.invalidation import invalidate_persona_cache

# 在数据修改后调用
cache_manager = get_cache_manager()
if cache_manager.is_enabled():
    invalidate_persona_cache(cache_manager, pc_id="xxx")
```

### 添加新的业务缓存失效

如果需要为新的业务模块添加缓存失效，可以：

1. 在 `invalidation.py` 中添加业务特定函数
2. 定义该业务的缓存模式
3. 在业务服务的数据修改方法中调用

```python
def invalidate_xxx_cache(cache_manager, xxx_id: Optional[str] = None):
    """失效 XXX 相关的缓存"""
    patterns = [
        "maimnp:http:*xxx/public*",
    ]
    if xxx_id:
        patterns.append(f"maimnp:http:*xxx/{xxx_id}*")
    invalidate_cache_sync(cache_manager, patterns)
```

## 依赖安装

在 conda 环境中安装了 `openai` 包（用于 AI 内容审核模块）：

```bash
/Users/cuckoo/miniconda3/envs/mai_notebook/bin/pip install openai
```

## 后续优化建议

1. 考虑使用缓存标签（tags）来更精确地管理缓存失效
2. 可以添加缓存失效的性能监控指标
3. 对于高频更新的数据，可以考虑使用更短的 TTL
4. 可以考虑实现批量缓存失效，减少 Redis 调用次数

## 相关文件

- `app/core/cache/invalidation.py`: 通用缓存失效模块
- `app/services/persona_service.py`: 人设卡服务（已集成缓存失效）
- `app/services/knowledge_service.py`: 知识库服务（已集成缓存失效）
- `app/services/file_upload_service.py`: 文件上传服务（已集成缓存失效）
- `app/core/cache/manager.py`: 缓存管理器（提供 invalidate_pattern 方法）
