# ExceptionInjector 使用指南

## 概述

`ExceptionInjector` 是一个强大的测试工具，用于在测试中系统化地注入各种类型的异常，以测试应用程序的异常处理逻辑。

## 数据库异常注入功能

### 支持的数据库操作类型

ExceptionInjector 现在支持以下所有常见的数据库操作：

1. **query** - 查询操作（Session.query）
2. **commit** - 提交操作（Session.commit）
3. **add** - 添加操作（Session.add）
4. **delete** - 删除操作（Session.delete）
5. **update** - 更新操作（Session.execute）
6. **refresh** - 刷新操作（Session.refresh）
7. **flush** - 刷新缓存操作（Session.flush）
8. **rollback** - 回滚操作（Session.rollback）
9. **scalar** - 标量查询操作（Query.scalar）
10. **first** - 获取第一条记录操作（Query.first）
11. **filter** - 过滤操作（Query.filter）
12. **count** - 计数操作（Query.count）
13. **all** - 所有操作（同时注入上述所有操作）

### 基本使用示例

#### 1. 注入查询错误

```python
from tests.helpers.exception_injector import ExceptionInjector
from sqlalchemy.exc import SQLAlchemyError

injector = ExceptionInjector()

# 测试查询操作失败
with injector.inject_database_error("query"):
    result = user_service.get_user_by_id("test_id")
    assert result is None  # 应该返回 None 而不是抛出异常
```

#### 2. 注入提交错误

```python
# 测试提交操作失败
with injector.inject_database_error("commit"):
    result = user_service.create_user("testuser", "test@example.com", "password")
    assert result is None  # 创建失败应该返回 None
```

#### 3. 注入刷新错误

```python
# 测试 refresh 操作失败
with injector.inject_database_error("refresh"):
    # 测试在 refresh 时发生错误的处理
    result = user_service.update_user(user_id, username="newname")
    assert result is not None  # 应该优雅地处理错误
```

#### 4. 注入多个操作错误

```python
# 同时注入多个数据库操作错误
configs = [
    {"type": "database", "operation": "query"},
    {"type": "database", "operation": "commit"},
    {"type": "database", "operation": "refresh"}
]

with injector.inject_multiple_errors(configs):
    # 测试代码
    pass
```

#### 5. 注入所有数据库操作错误

```python
# 使用 "all" 操作类型注入所有数据库操作的错误
with injector.inject_database_error("all"):
    # 在此上下文中，所有数据库操作都会失败
    result = user_service.get_user_by_id("test_id")
    assert result is None
```

### 自定义错误类型和消息

```python
# 使用自定义错误类型
with injector.inject_database_error(
    operation="query",
    error_type=ValueError,
    error_message="Custom database error"
):
    result = user_service.get_user_by_id("test_id")
    assert result is None
```

### 完整性约束错误

```python
# 注入唯一约束违反错误
with injector.inject_integrity_error("unique_constraint"):
    result = user_service.create_user("duplicate", "test@example.com", "password")
    assert result is None
```

### 操作错误（连接丢失、超时等）

```python
# 注入数据库连接丢失错误
with injector.inject_operational_error("Database connection lost"):
    result = user_service.get_all_users()
    assert result == []
```

## 实际应用场景

### 场景 1：测试用户服务的数据库异常处理

```python
def test_user_service_query_error(db_session):
    """测试用户服务在查询失败时的处理"""
    user_service = UserService(db_session)
    injector = ExceptionInjector()
    
    with injector.inject_database_error("query"):
        result = user_service.get_user_by_id("test_id")
        
        # 验证返回 None 而不是抛出异常
        assert result is None
        
        # 验证错误被记录
        # assert "Error getting user by ID" in caplog.text
```

### 场景 2：测试提交失败后的回滚

```python
def test_user_service_commit_error_rollback(db_session):
    """测试提交失败后数据库正确回滚"""
    user_service = UserService(db_session)
    injector = ExceptionInjector()
    
    with injector.inject_database_error("commit"):
        result = user_service.create_user("testuser", "test@example.com", "password")
        
        # 验证创建失败
        assert result is None
        
        # 验证数据库状态一致（没有部分提交的数据）
        assert db_session.query(User).filter(User.username == "testuser").first() is None
```

### 场景 3：测试 refresh 操作失败

```python
def test_user_service_refresh_error(db_session):
    """测试 refresh 操作失败时的处理"""
    user_service = UserService(db_session)
    injector = ExceptionInjector()
    
    # 先创建一个用户
    user = user_service.create_user("testuser", "test@example.com", "password")
    assert user is not None
    
    # 注入 refresh 错误
    with injector.inject_database_error("refresh"):
        # 尝试更新用户（通常会在 commit 后调用 refresh）
        result = user_service.update_user(user.id, username="newname")
        
        # 验证更新操作的错误处理
        # 具体行为取决于服务的实现
```

### 场景 4：测试复杂的数据库操作序列

```python
def test_complex_database_operation_with_errors(db_session):
    """测试复杂数据库操作序列中的错误处理"""
    user_service = UserService(db_session)
    injector = ExceptionInjector()
    
    # 测试在 flush 时发生错误
    with injector.inject_database_error("flush"):
        result = user_service.batch_create_users([
            {"username": "user1", "email": "user1@example.com", "password": "pass1"},
            {"username": "user2", "email": "user2@example.com", "password": "pass2"}
        ])
        
        # 验证批量操作的错误处理
        assert result is None or result == []
```

### 场景 5：测试 scalar 查询错误

```python
def test_user_count_with_scalar_error(db_session):
    """测试 scalar 查询失败时的处理"""
    user_service = UserService(db_session)
    injector = ExceptionInjector()
    
    with injector.inject_database_error("scalar"):
        # 假设有一个获取用户总数的方法使用 scalar()
        count = user_service.get_total_user_count()
        
        # 验证返回默认值（如 0）而不是抛出异常
        assert count == 0
```

## 其他异常注入功能

### 验证错误注入

```python
with injector.inject_validation_error("email"):
    result = user_service.create_user("test", "invalid-email", "password")
    assert result is None
```

### 权限错误注入

```python
with injector.inject_permission_error():
    with pytest.raises(PermissionError):
        user_service.promote_to_admin("user_id", "wrong_password")
```

### 网络错误注入

```python
with injector.inject_network_error("timeout"):
    result = email_service.send_email("test@example.com", "subject", "body")
    assert result is False
```

### 文件系统错误注入

```python
with injector.inject_file_system_error("write"):
    result = file_service.save_file("test.txt", b"content")
    assert result is False
```

## 高级功能

### 创建间歇性错误 Mock

```python
# 创建一个间歇性失败的 mock（2次成功，1次失败）
mock = injector.create_intermittent_error_mock(
    ConnectionError("Network error"),
    success_count=2,
    failure_count=1
)

# 使用 mock
assert mock() is None  # 成功
assert mock() is None  # 成功
with pytest.raises(ConnectionError):
    mock()  # 失败
assert mock() is None  # 成功（新循环）
```

### 创建延迟错误 Mock

```python
# 创建一个在第3次调用时抛出错误的 mock
mock = injector.create_mock_with_error(
    ValueError("Error on third call"),
    call_count=3
)

mock()  # 正常
mock()  # 正常
with pytest.raises(ValueError):
    mock()  # 抛出错误
```

## 最佳实践

1. **使用上下文管理器**：始终使用 `with` 语句确保错误注入后自动清理
2. **测试特定操作**：优先使用特定的操作类型（如 "query", "commit"）而不是 "all"
3. **验证错误处理**：不仅要测试函数不抛出异常，还要验证返回值和日志
4. **测试数据一致性**：验证错误发生后数据库状态保持一致
5. **组合测试**：使用 `inject_multiple_errors` 测试复杂的错误场景

## 注意事项

1. 错误注入使用 `unittest.mock.patch`，可能会影响测试隔离性
2. 使用 "all" 操作类型会注入所有数据库操作的错误，可能导致测试过于严格
3. 某些数据库操作（如 rollback）很少失败，注入这些错误主要用于极端情况测试
4. 确保在测试后正确清理，上下文管理器会自动处理这一点

## 总结

ExceptionInjector 的增强数据库异常注入功能提供了全面的数据库操作错误测试能力，覆盖了从基本的 CRUD 操作到高级的事务管理操作。通过系统化地测试这些错误路径，可以确保应用程序在各种数据库异常情况下都能优雅地处理错误，保持数据一致性和系统稳定性。
