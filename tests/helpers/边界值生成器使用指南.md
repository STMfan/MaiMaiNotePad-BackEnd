# 边界值生成器使用指南

## 概述

`BoundaryValueGenerator` 是一个用于自动生成边界值和极端情况测试用例的工具类。它可以帮助开发者系统化地测试函数在各种边界条件下的行为，包括空值、最大值、最小值、特殊字符等。

## 主要功能

- 生成各种类型的边界值（字符串、整数、浮点数、列表、字典等）
- 自动生成测试用例
- 支持自定义边界值范围
- 提供预期行为标记（正常处理、抛出异常、返回 None）
- **集成到 pytest 框架，提供便捷的 fixtures 和辅助函数**

## Pytest 集成

### 可用的 Fixtures

边界值生成器已经集成到 pytest 框架中，提供以下 fixtures：

#### 1. `boundary_generator` (session scope)

提供 BoundaryValueGenerator 实例，可以在所有测试中重用：

```python
def test_custom_boundaries(boundary_generator):
    # 使用自定义参数生成边界值
    boundaries = boundary_generator.generate_string_boundaries(max_length=50)
    for boundary in boundaries:
        # 测试逻辑
        pass
```

#### 2. `null_boundaries` (function scope)

提供空值边界值列表：

```python
def test_null_handling(null_boundaries):
    for boundary in null_boundaries:
        result = my_function(boundary.value)
        assert result is not None or boundary.value is None
```

#### 3. `string_boundaries` (function scope)

提供字符串边界值列表（默认最大长度 10000）：

```python
def test_string_processing(string_boundaries):
    for boundary in string_boundaries:
        if boundary.expected_behavior == "raise_exception":
            with pytest.raises(Exception):
                process_string(boundary.value)
        else:
            result = process_string(boundary.value)
            assert isinstance(result, str)
```

#### 4. `integer_boundaries` (function scope)

提供整数边界值列表：

```python
def test_integer_validation(integer_boundaries):
    for boundary in integer_boundaries:
        result = validate_integer(boundary.value)
        # 验证逻辑
```

#### 5. `float_boundaries` (function scope)

提供浮点数边界值列表：

```python
def test_float_calculation(float_boundaries):
    for boundary in float_boundaries:
        if not math.isnan(boundary.value):
            result = calculate(boundary.value)
            assert isinstance(result, float)
```

#### 6. `list_boundaries` (function scope)

提供列表边界值列表：

```python
def test_list_processing(list_boundaries):
    for boundary in list_boundaries:
        result = process_list(boundary.value)
        assert isinstance(result, list)
```

#### 7. `dict_boundaries` (function scope)

提供字典边界值列表：

```python
def test_dict_processing(dict_boundaries):
    for boundary in dict_boundaries:
        result = process_dict(boundary.value)
        assert isinstance(result, dict)
```

### 辅助函数

#### 1. `assert_boundary_behavior(boundary_value, test_func, *args, **kwargs)`

根据边界值的预期行为自动执行测试并进行断言：

```python
from tests.conftest import assert_boundary_behavior

def test_process_data(boundary_generator):
    boundaries = boundary_generator.generate_string_boundaries()
    for boundary in boundaries:
        result = assert_boundary_behavior(
            boundary,
            process_data,
            boundary.value
        )
        if result is not None:
            assert isinstance(result, dict)
```

#### 2. `generate_null_test_cases(function, param_name, include_nested=True)`

便捷函数，生成空值测试用例：

```python
from tests.conftest import generate_null_test_cases

def test_user_creation():
    def create_user(username, email):
        return {"username": username, "email": email}
    
    test_cases = generate_null_test_cases(create_user, "username")
    for test_case in test_cases:
        result = create_user(test_case["param_value"], "test@example.com")
        # 验证逻辑
```

#### 3. `generate_max_value_test_cases(function, param_name, param_type, max_value, **kwargs)`

便捷函数，生成最大值测试用例：

```python
from tests.conftest import generate_max_value_test_cases

def test_age_validation():
    def validate_age(age):
        return 0 <= age <= 150
    
    test_cases = generate_max_value_test_cases(
        validate_age, "age", "integer", max_value=150
    )
    for test_case in test_cases:
        result = validate_age(test_case["param_value"])
        # 验证逻辑
```

#### 4. `generate_concurrent_test_cases(function, num_threads, num_operations, operation_type)`

便捷函数，生成并发测试用例：

```python
from tests.conftest import generate_concurrent_test_cases

def test_concurrent_counter():
    def increment(counter):
        counter["value"] += 1
    
    test_cases = generate_concurrent_test_cases(
        increment, num_threads=[2, 10], operation_type="write"
    )
    for test_case in test_cases:
        # 设置并发测试
        pass
```

## 快速开始

### 使用 Pytest Fixtures（推荐）

边界值生成器已集成到 pytest 框架中，可以直接使用 fixtures：

```python
def test_username_validation(string_boundaries):
    """使用 string_boundaries fixture 测试用户名验证"""
    def validate_username(username: str) -> bool:
        return 3 <= len(username) <= 20
    
    for boundary in string_boundaries:
        result = validate_username(boundary.value)
        # 验证逻辑
```

### 基本使用

如果需要自定义配置，可以直接使用生成器：

```python
from tests.helpers.boundary_generator import BoundaryValueGenerator

# 创建生成器实例
generator = BoundaryValueGenerator()

# 生成字符串边界值
string_boundaries = generator.generate_string_boundaries()
for boundary in string_boundaries:
    print(f"{boundary.description}: {boundary.value}")
```

### 使用辅助函数

也可以使用便捷的辅助函数：

```python
from tests.conftest import generate_null_test_cases, assert_boundary_behavior

def test_data_processing():
    def process_data(data):
        return data
    
    # 生成空值测试用例
    test_cases = generate_null_test_cases(process_data, "data")
    
    for test_case in test_cases:
        result = process_data(test_case["param_value"])
        # 验证逻辑
```

### 生成特定类型的边界值

```python
# 生成整数边界值（指定范围）
int_boundaries = generator.generate_integer_boundaries(min_value=0, max_value=100)

# 生成浮点数边界值
float_boundaries = generator.generate_float_boundaries(min_value=0.0, max_value=1.0)

# 生成列表边界值（指定最大长度和元素类型）
list_boundaries = generator.generate_list_boundaries(max_length=10, element_type=str)

# 生成字典边界值
dict_boundaries = generator.generate_dict_boundaries(max_keys=10)

# 生成空值
null_values = generator.generate_null_values()
```

### 生成空值测试用例

```python
# 为单个参数生成空值测试用例
def process_data(data):
    return data

test_cases = generator.generate_null_test_cases(
    function=process_data,
    param_name="data",
    include_nested=True  # 包含嵌套结构中的空值
)

# 为多个参数生成空值组合测试用例
def create_user(username, email, password):
    return {"username": username, "email": email}

combination_cases = generator.generate_null_combinations(
    function=create_user,
    param_names=["username", "email", "password"]
)
```

## 详细使用示例

### 示例 1：测试字符串处理函数

```python
import pytest
from tests.helpers.boundary_generator import BoundaryValueGenerator

def process_username(username: str) -> str:
    """处理用户名"""
    if not username:
        raise ValueError("Username cannot be empty")
    if len(username) > 50:
        raise ValueError("Username too long")
    return username.strip().lower()

def test_process_username_boundaries():
    """测试用户名处理的边界情况"""
    generator = BoundaryValueGenerator()
    
    # 生成字符串边界值
    boundaries = generator.generate_string_boundaries(max_length=50)
    
    for boundary in boundaries:
        if boundary.expected_behavior == "raise_exception":
            # 预期抛出异常的情况
            with pytest.raises(ValueError):
                process_username(boundary.value)
        elif boundary.expected_behavior == "handle_gracefully":
            # 预期正常处理的情况
            try:
                result = process_username(boundary.value)
                assert isinstance(result, str)
            except ValueError:
                # 某些边界值可能合理地抛出异常
                pass
```

### 示例 2：测试整数验证函数

```python
def validate_age(age: int) -> bool:
    """验证年龄"""
    if age < 0 or age > 150:
        return False
    return True

def test_validate_age_boundaries():
    """测试年龄验证的边界情况"""
    generator = BoundaryValueGenerator()
    
    # 生成整数边界值
    boundaries = generator.generate_integer_boundaries(min_value=0, max_value=150)
    
    for boundary in boundaries:
        result = validate_age(boundary.value)
        
        # 验证边界值的处理
        if boundary.category == "extreme":
            # 极端值应该返回 False
            assert result is False, f"Expected False for {boundary.description}"
        elif boundary.value in [0, 150]:
            # 边界值应该返回 True
            assert result is True, f"Expected True for {boundary.description}"
```

### 示例 3：使用 generate_test_cases 自动生成测试

```python
def greet(name: str) -> str:
    """问候函数"""
    if not name:
        return "Hello, stranger!"
    return f"Hello, {name}!"

def test_greet_with_generated_cases():
    """使用自动生成的测试用例测试问候函数"""
    generator = BoundaryValueGenerator()
    
    # 自动生成测试用例
    test_cases = generator.generate_test_cases(
        function=greet,
        param_name="name",
        param_type="string",
        max_length=100
    )
    
    for test_case in test_cases:
        param_value = test_case["param_value"]
        description = test_case["description"]
        
        try:
            result = greet(param_value)
            assert isinstance(result, str), f"Failed for {description}"
        except Exception as e:
            # 记录异常情况
            print(f"Exception for {description}: {e}")
```

### 示例 4：测试列表处理函数

```python
def process_items(items: list) -> int:
    """处理项目列表"""
    if not items:
        return 0
    if len(items) > 100:
        raise ValueError("Too many items")
    return len([item for item in items if item is not None])

def test_process_items_boundaries():
    """测试项目处理的边界情况"""
    generator = BoundaryValueGenerator()
    
    # 生成列表边界值
    boundaries = generator.generate_list_boundaries(max_length=100)
    
    for boundary in boundaries:
        if boundary.expected_behavior == "raise_exception":
            with pytest.raises(ValueError):
                process_items(boundary.value)
        else:
            result = process_items(boundary.value)
            assert isinstance(result, int)
            assert result >= 0
```

### 示例 5：生成所有类型的边界值

```python
def test_all_boundary_types():
    """测试所有类型的边界值生成"""
    generator = BoundaryValueGenerator()
    
    # 生成所有类型的边界值
    all_boundaries = generator.generate_all_boundaries()
    
    # 遍历所有类型
    for type_name, boundaries in all_boundaries.items():
        print(f"\n{type_name.upper()} boundaries:")
        for boundary in boundaries:
            print(f"  - {boundary.description}: {boundary.value}")
```

### 示例 6：只生成特定类型的边界值

```python
def test_specific_type_boundaries():
    """只生成字符串类型的边界值"""
    generator = BoundaryValueGenerator()
    
    # 只生成字符串边界值
    string_only = generator.generate_all_boundaries(value_type="string")
    
    assert "string" in string_only
    assert len(string_only) == 1
    
    for boundary in string_only["string"]:
        print(f"{boundary.description}: {boundary.value}")
```

### 示例 7：生成空值测试用例

```python
def test_null_value_handling():
    """测试函数对空值的处理"""
    generator = BoundaryValueGenerator()
    
    def process_user_data(user_data):
        """处理用户数据"""
        if user_data is None:
            return {"error": "No data provided"}
        if not user_data:
            return {"error": "Empty data"}
        return {"status": "success", "data": user_data}
    
    # 生成空值测试用例（包含嵌套结构）
    test_cases = generator.generate_null_test_cases(
        function=process_user_data,
        param_name="user_data",
        include_nested=True
    )
    
    for test_case in test_cases:
        param_value = test_case["param_value"]
        description = test_case["description"]
        test_type = test_case["test_type"]
        
        result = process_user_data(param_value)
        print(f"{description} ({test_type}): {result}")
        
        # 验证函数正确处理空值
        assert isinstance(result, dict)
```

### 示例 8：测试多参数空值组合

```python
def test_multiple_params_null_combinations():
    """测试多个参数的空值组合"""
    generator = BoundaryValueGenerator()
    
    def create_account(username, email, password):
        """创建账户"""
        if not username or not email or not password:
            return None
        return {
            "username": username,
            "email": email,
            "created": True
        }
    
    # 生成多参数空值组合测试用例
    test_cases = generator.generate_null_combinations(
        function=create_account,
        param_names=["username", "email", "password"]
    )
    
    for test_case in test_cases:
        params = test_case["params"]
        description = test_case["description"]
        test_type = test_case["test_type"]
        
        result = create_account(**params)
        print(f"{description} ({test_type}): {result}")
        
        # 验证当任何参数为 None 时返回 None
        if any(v is None for v in params.values()):
            assert result is None
```

### 示例 9：测试嵌套结构中的空值

```python
def test_nested_null_values():
    """测试嵌套结构中的空值处理"""
    generator = BoundaryValueGenerator()
    
    def process_nested_data(data):
        """处理嵌套数据结构"""
        if data is None:
            return {"error": "No data"}
        
        if isinstance(data, dict):
            # 处理字典中的 None 值
            cleaned = {k: v for k, v in data.items() if v is not None}
            return {"cleaned": cleaned, "removed": len(data) - len(cleaned)}
        
        if isinstance(data, list):
            # 处理列表中的 None 值
            cleaned = [item for item in data if item is not None]
            return {"cleaned": cleaned, "removed": len(data) - len(cleaned)}
        
        return {"data": data}
    
    # 生成包含嵌套空值的测试用例
    test_cases = generator.generate_null_test_cases(
        function=process_nested_data,
        param_name="data",
        include_nested=True
    )
    
    # 只测试嵌套空值的情况
    nested_cases = [tc for tc in test_cases if tc["test_type"] == "nested_null"]
    
    for test_case in nested_cases:
        param_value = test_case["param_value"]
        description = test_case["description"]
        
        result = process_nested_data(param_value)
        print(f"{description}: {result}")
        
        # 验证函数正确处理嵌套空值
        assert isinstance(result, dict)
```

### 示例 10：测试最大值边界情况

```python
def test_max_value_boundaries():
    """测试最大值边界情况"""
    generator = BoundaryValueGenerator()
    
    def validate_username(username: str) -> bool:
        """验证用户名长度"""
        return 3 <= len(username) <= 20
    
    # 生成最大值测试用例
    test_cases = generator.generate_max_value_test_cases(
        function=validate_username,
        param_name="username",
        param_type="string",
        max_value=20
    )
    
    for test_case in test_cases:
        param_value = test_case["param_value"]
        description = test_case["description"]
        test_type = test_case["test_type"]
        
        result = validate_username(param_value)
        print(f"{description} ({test_type}): {result}")
        
        # 验证边界值处理
        if test_type == "at_max":
            # 最大值应该通过验证
            assert result is True
        elif test_type == "below_max":
            # 低于最大值应该通过验证（如果大于最小值）
            if len(param_value) >= 3:
                assert result is True
        elif test_type in ["above_max", "far_above_max"]:
            # 超过最大值应该失败
            assert result is False
```

### 示例 11：测试整数最大值

```python
def test_integer_max_values():
    """测试整数最大值边界"""
    generator = BoundaryValueGenerator()
    
    def validate_age(age: int) -> bool:
        """验证年龄范围"""
        return 0 <= age <= 150
    
    # 生成整数最大值测试用例
    test_cases = generator.generate_max_value_test_cases(
        function=validate_age,
        param_name="age",
        param_type="integer",
        max_value=150
    )
    
    for test_case in test_cases:
        param_value = test_case["param_value"]
        test_type = test_case["test_type"]
        
        result = validate_age(param_value)
        
        # 验证边界值处理
        if test_type in ["at_max", "below_max"]:
            # 在范围内的值应该通过
            if param_value >= 0:
                assert result is True
        elif test_type in ["above_max", "system_max"]:
            # 超出范围的值应该失败
            assert result is False
```

### 示例 12：测试列表最大长度

```python
def test_list_max_length():
    """测试列表最大长度边界"""
    generator = BoundaryValueGenerator()
    
    def process_items(items: list) -> dict:
        """处理项目列表"""
        if len(items) > 100:
            return {"error": "Too many items"}
        return {"count": len(items), "items": items}
    
    # 生成列表最大值测试用例
    test_cases = generator.generate_max_value_test_cases(
        function=process_items,
        param_name="items",
        param_type="list",
        max_value=100,
        element_type=str
    )
    
    for test_case in test_cases:
        param_value = test_case["param_value"]
        test_type = test_case["test_type"]
        
        result = process_items(param_value)
        
        # 验证边界值处理
        if test_type in ["at_max", "below_max"]:
            # 在限制内的列表应该正常处理
            assert "count" in result
            assert result["count"] == len(param_value)
        elif test_type in ["above_max", "far_above_max"]:
            # 超出限制的列表应该返回错误
            assert "error" in result
```

### 示例 13：测试浮点数最大值

```python
def test_float_max_values():
    """测试浮点数最大值边界"""
    generator = BoundaryValueGenerator()
    
    def validate_temperature(temp: float) -> bool:
        """验证温度范围"""
        return -273.15 <= temp <= 1000.0
    
    # 生成浮点数最大值测试用例
    test_cases = generator.generate_max_value_test_cases(
        function=validate_temperature,
        param_name="temp",
        param_type="float",
        max_value=1000.0
    )
    
    for test_case in test_cases:
        param_value = test_case["param_value"]
        test_type = test_case["test_type"]
        
        result = validate_temperature(param_value)
        
        # 验证边界值处理
        if test_type in ["at_max", "below_max"]:
            # 在范围内的值应该通过
            if param_value >= -273.15:
                assert result is True
        elif test_type in ["above_max", "infinity", "system_max"]:
            # 超出范围的值应该失败
            assert result is False
```

### 示例 14：测试字典最大键数

```python
def test_dict_max_keys():
    """测试字典最大键数边界"""
    generator = BoundaryValueGenerator()
    
    def process_config(config: dict) -> dict:
        """处理配置字典"""
        if len(config) > 50:
            return {"error": "Too many configuration keys"}
        return {"status": "ok", "key_count": len(config)}
    
    # 生成字典最大值测试用例
    test_cases = generator.generate_max_value_test_cases(
        function=process_config,
        param_name="config",
        param_type="dict",
        max_value=50
    )
    
    for test_case in test_cases:
        param_value = test_case["param_value"]
        test_type = test_case["test_type"]
        
        result = process_config(param_value)
        
        # 验证边界值处理
        if test_type in ["at_max", "below_max"]:
            # 在限制内的字典应该正常处理
            assert result["status"] == "ok"
            assert result["key_count"] == len(param_value)
        elif test_type in ["above_max", "far_above_max"]:
            # 超出限制的字典应该返回错误
            assert "error" in result
```

### 示例 15：生成并发测试用例

```python
def test_concurrent_operations():
    """测试并发操作"""
    import threading
    generator = BoundaryValueGenerator()
    
    def increment_counter(counter_dict, key):
        """增加计数器"""
        counter_dict[key] = counter_dict.get(key, 0) + 1
    
    # 生成并发测试用例
    test_cases = generator.generate_concurrent_test_cases(
        function=increment_counter,
        num_threads=[2, 5, 10],
        num_operations=[10, 100],
        operation_type="write"
    )
    
    for test_case in test_cases:
        num_threads = test_case["num_threads"]
        num_operations = test_case["num_operations"]
        test_type = test_case["test_type"]
        
        # 创建共享资源
        counter = {}
        
        # 创建线程
        threads = []
        for i in range(num_threads):
            thread = threading.Thread(
                target=lambda: [increment_counter(counter, "count") for _ in range(num_operations)]
            )
            threads.append(thread)
        
        # 启动所有线程
        for thread in threads:
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        # 验证结果
        expected_count = num_threads * num_operations
        actual_count = counter.get("count", 0)
        
        print(f"{test_case['description']}: expected={expected_count}, actual={actual_count}")
        
        # 注意：如果没有适当的锁机制，实际计数可能小于预期
        # 这正是并发测试要发现的问题
```

### 示例 16：测试竞态条件

```python
def test_race_condition():
    """测试竞态条件"""
    import threading
    import time
    generator = BoundaryValueGenerator()
    
    def update_shared_resource(resource, delay=0.001):
        """更新共享资源"""
        current = resource["value"]
        time.sleep(delay)  # 模拟处理时间
        resource["value"] = current + 1
    
    # 生成竞态条件测试用例
    test_cases = generator.generate_concurrent_test_cases(
        function=update_shared_resource,
        operation_type="same_resource"
    )
    
    # 只测试竞态条件测试用例
    race_cases = [tc for tc in test_cases if tc["test_type"] == "race_condition"]
    
    for test_case in race_cases:
        num_threads = test_case["num_threads"]
        
        # 创建共享资源
        resource = {"value": 0}
        
        # 创建线程
        threads = []
        for i in range(num_threads):
            thread = threading.Thread(target=update_shared_resource, args=(resource,))
            threads.append(thread)
        
        # 启动所有线程
        for thread in threads:
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        # 验证竞态条件
        expected_value = num_threads
        actual_value = resource["value"]
        
        print(f"{test_case['description']}: expected={expected_value}, actual={actual_value}")
        
        # 如果存在竞态条件，实际值会小于预期值
        if actual_value < expected_value:
            print(f"  ⚠️  Race condition detected! Lost {expected_value - actual_value} updates")
```

### 示例 17：测试线程安全性

```python
def test_thread_safety():
    """测试线程安全性"""
    import threading
    from queue import Queue
    generator = BoundaryValueGenerator()
    
    class ThreadSafeCounter:
        """线程安全的计数器"""
        def __init__(self):
            self.value = 0
            self.lock = threading.Lock()
        
        def increment(self):
            with self.lock:
                self.value += 1
    
    def increment_safe_counter(counter):
        """增加线程安全计数器"""
        counter.increment()
    
    # 生成并发测试用例
    test_cases = generator.generate_concurrent_test_cases(
        function=increment_safe_counter,
        num_threads=[10, 50, 100],
        num_operations=[100],
        operation_type="write"
    )
    
    for test_case in test_cases:
        num_threads = test_case["num_threads"]
        num_operations = test_case["num_operations"]
        
        # 创建线程安全计数器
        counter = ThreadSafeCounter()
        
        # 创建线程
        threads = []
        for i in range(num_threads):
            thread = threading.Thread(
                target=lambda: [increment_safe_counter(counter) for _ in range(num_operations)]
            )
            threads.append(thread)
        
        # 启动所有线程
        for thread in threads:
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        # 验证结果
        expected_count = num_threads * num_operations
        actual_count = counter.value
        
        print(f"{test_case['description']}: expected={expected_count}, actual={actual_count}")
        
        # 线程安全的实现应该保证计数准确
        assert actual_count == expected_count, f"Thread safety violation: {actual_count} != {expected_count}"
```

## BoundaryValue 数据类

每个边界值都是一个 `BoundaryValue` 实例，包含以下字段：

- `value`: 边界值本身
- `description`: 边界值的描述
- `expected_behavior`: 预期行为
  - `"handle_gracefully"`: 应该正常处理
  - `"raise_exception"`: 应该抛出异常
  - `"return_none"`: 应该返回 None
- `category`: 边界值类别
  - `"boundary"`: 一般边界值
  - `"null"`: 空值
  - `"empty"`: 空容器
  - `"max"`: 最大值
  - `"min"`: 最小值
  - `"extreme"`: 极端值

## API 参考

### generate_null_values()

生成基本的空值测试用例。

**返回**: `List[BoundaryValue]` - 包含 None、空字符串、空列表、空字典等的边界值列表

**示例**:
```python
null_values = generator.generate_null_values()
# 返回: [None, "", [], {}, (), set()]
```

### generate_null_test_cases(function, param_name, include_nested=True)

为指定函数和参数生成全面的空值测试用例。

**参数**:
- `function` (Callable): 要测试的函数
- `param_name` (str): 参数名称
- `include_nested` (bool): 是否包含嵌套结构中的空值测试，默认为 True

**返回**: `List[Dict[str, Any]]` - 空值测试用例列表，每个测试用例包含：
- `function`: 函数引用
- `param_name`: 参数名称
- `param_value`: 参数值
- `description`: 测试描述
- `expected_behavior`: 预期行为
- `category`: 边界值类别
- `test_type`: 测试类型（"basic_null" 或 "nested_null"）

**示例**:
```python
def process_data(data):
    return data

test_cases = generator.generate_null_test_cases(
    function=process_data,
    param_name="data",
    include_nested=True
)
# 生成包含基本空值和嵌套空值的测试用例
```

### generate_null_combinations(function, param_names)

为多个参数生成空值组合测试用例。

**参数**:
- `function` (Callable): 要测试的函数
- `param_names` (List[str]): 参数名称列表

**返回**: `List[Dict[str, Any]]` - 空值组合测试用例列表，每个测试用例包含：
- `function`: 函数引用
- `params`: 参数字典（参数名 -> 参数值）
- `description`: 测试描述
- `expected_behavior`: 预期行为
- `category`: 边界值类别
- `test_type`: 测试类型（"single_null_param"、"all_null_params" 或 "multiple_null_params"）

**示例**:
```python
def create_user(username, email, password):
    return {"username": username, "email": email}

test_cases = generator.generate_null_combinations(
    function=create_user,
    param_names=["username", "email", "password"]
)
# 生成单个参数为 None、所有参数为 None、以及两两组合为 None 的测试用例
```

### generate_max_value_test_cases(function, param_name, param_type, max_value=None, **kwargs)

为指定函数和参数生成最大值测试用例。

**参数**:
- `function` (Callable): 要测试的函数
- `param_name` (str): 参数名称
- `param_type` (str): 参数类型（"string"、"integer"、"float"、"list"、"dict"）
- `max_value` (Optional[Union[int, float, str]]): 最大值限制
  - string: 最大字符串长度
  - integer/float: 最大数值
  - list: 最大列表长度
  - dict: 最大键数量
- `**kwargs`: 传递给边界值生成器的额外参数（如 element_type）

**返回**: `List[Dict[str, Any]]` - 最大值测试用例列表，每个测试用例包含：
- `function`: 函数引用
- `param_name`: 参数名称
- `param_value`: 参数值
- `description`: 测试描述
- `expected_behavior`: 预期行为
- `category`: 边界值类别
- `test_type`: 测试类型（"at_max"、"below_max"、"above_max"、"far_above_max"、"system_max"、"infinity"）

**示例**:
```python
def validate_age(age: int) -> bool:
    return 0 <= age <= 150

test_cases = generator.generate_max_value_test_cases(
    function=validate_age,
    param_name="age",
    param_type="integer",
    max_value=150
)
# 生成最大值、低于最大值、超过最大值等测试用例
```

### generate_concurrent_test_cases(function, num_threads=None, num_operations=None, operation_type="mixed")

为指定函数生成并发测试用例。

**参数**:
- `function` (Callable): 要测试的函数
- `num_threads` (Optional[Union[int, List[int]]]): 并发线程数，默认为 [2, 5, 10, 50, 100]
- `num_operations` (Optional[Union[int, List[int]]]): 每个线程的操作次数，默认为 [1, 10, 100]
- `operation_type` (str): 操作类型
  - "read": 只读操作
  - "write": 只写操作
  - "mixed": 混合读写操作
  - "same_resource": 访问相同资源
  - "different_resources": 访问不同资源

**返回**: `List[Dict[str, Any]]` - 并发测试用例列表，每个测试用例包含：
- `function`: 函数引用
- `num_threads`: 线程数
- `num_operations`: 操作次数
- `operation_type`: 操作类型
- `description`: 测试描述
- `expected_behavior`: 预期行为
- `category`: 测试类别（"concurrent"）
- `test_type`: 测试类型（"basic_concurrent"、"race_condition"、"stress_test"、"write_conflict"、"read_consistency"、"deadlock_detection"、"baseline"）

**示例**:
```python
def increment_counter(counter_dict, key):
    counter_dict[key] = counter_dict.get(key, 0) + 1

test_cases = generator.generate_concurrent_test_cases(
    function=increment_counter,
    num_threads=[2, 10],
    num_operations=[10, 100],
    operation_type="write"
)
# 生成多种并发场景的测试用例
```

## 支持的边界值类型

### 1. 空值 (Null Values)
- None
- 空字符串 ""
- 空列表 []
- 空字典 {}
- 空元组 ()
- 空集合 set()

### 2. 字符串边界值
- 空字符串
- 单字符
- 最大长度字符串
- 超长字符串
- 特殊字符（空格、换行、制表符）
- XSS 攻击字符串
- SQL 注入字符串
- 路径遍历字符串
- Unicode 字符（中文、emoji）
- 控制字符

### 3. 整数边界值
- 零
- 正数和负数
- 最小值和最大值
- 超出范围的值
- 系统级边界值（sys.maxsize）

### 4. 浮点数边界值
- 零
- 正数和负数
- 正无穷大和负无穷大
- NaN (Not a Number)
- 系统级边界值（sys.float_info.min/max）
- Epsilon 值

### 5. 列表边界值
- 空列表
- 单元素列表
- 最大长度列表
- 超长列表
- 包含 None 的列表

### 6. 字典边界值
- 空字典
- 单键字典
- 最大键数字典
- 超大字典
- 包含 None 值的字典
- 包含空字符串键的字典

### 7. 日期时间边界值
- 最小日期时间 (0001-01-01)
- 最大日期时间 (9999-12-31)
- 当前日期时间
- 过去和未来的日期
- Unix epoch
- 32位时间戳溢出点

### 8. 布尔值边界值
- True 和 False
- 类似布尔值的其他值（0, 1, "", "true"）

### 9. UUID 边界值
- 有效的 UUID v4
- Nil UUID
- 无效的 UUID 字符串
- 空字符串

## 最佳实践

### 1. 选择合适的边界值类型

根据被测试函数的参数类型选择合适的边界值生成方法：

```python
# 字符串参数
boundaries = generator.generate_string_boundaries(max_length=50)

# 整数参数
boundaries = generator.generate_integer_boundaries(min_value=0, max_value=100)

# 列表参数
boundaries = generator.generate_list_boundaries(max_length=10, element_type=str)
```

### 2. 使用预期行为进行断言

根据 `expected_behavior` 字段编写相应的断言：

```python
for boundary in boundaries:
    if boundary.expected_behavior == "raise_exception":
        with pytest.raises(Exception):
            function_under_test(boundary.value)
    elif boundary.expected_behavior == "handle_gracefully":
        result = function_under_test(boundary.value)
        assert result is not None
```

### 3. 关注边界值类别

使用 `category` 字段来组织测试：

```python
# 只测试极端值
extreme_values = [bv for bv in boundaries if bv.category == "extreme"]

# 只测试空值
null_values = [bv for bv in boundaries if bv.category == "null"]
```

### 4. 自定义边界值范围

根据实际业务需求自定义边界值范围：

```python
# 用户名长度限制为 3-20 个字符
username_boundaries = generator.generate_string_boundaries(max_length=20)

# 年龄范围 0-150
age_boundaries = generator.generate_integer_boundaries(min_value=0, max_value=150)
```

### 5. 结合参数化测试

使用 pytest 的参数化测试功能：

```python
@pytest.mark.parametrize("boundary", generator.generate_string_boundaries())
def test_function_with_boundaries(boundary):
    """参数化测试"""
    if boundary.expected_behavior == "raise_exception":
        with pytest.raises(Exception):
            function_under_test(boundary.value)
    else:
        result = function_under_test(boundary.value)
        assert result is not None
```

## 常见问题

### Q1: 如何处理预期行为不确定的情况？

A: 可以使用 try-except 块来捕获异常，并根据实际情况进行断言：

```python
for boundary in boundaries:
    try:
        result = function_under_test(boundary.value)
        # 验证结果
        assert isinstance(result, expected_type)
    except Exception as e:
        # 验证异常是预期的
        assert isinstance(e, (ValueError, TypeError))
```

### Q2: 如何生成自定义的边界值？

A: 可以直接创建 `BoundaryValue` 实例：

```python
from tests.helpers.boundary_generator import BoundaryValue

custom_boundary = BoundaryValue(
    value="custom_value",
    description="Custom test value",
    expected_behavior="handle_gracefully",
    category="boundary"
)
```

### Q3: 如何测试多个参数的组合？

A: 可以为每个参数生成边界值，然后使用 itertools.product 生成组合：

```python
from itertools import product

param1_boundaries = generator.generate_string_boundaries()
param2_boundaries = generator.generate_integer_boundaries()

for bv1, bv2 in product(param1_boundaries, param2_boundaries):
    result = function_under_test(bv1.value, bv2.value)
    # 验证结果
```

### Q4: 生成的边界值太多，如何筛选？

A: 可以根据类别或预期行为进行筛选：

```python
# 只测试极端值和空值
filtered = [bv for bv in boundaries if bv.category in ["extreme", "null"]]

# 只测试预期抛出异常的情况
exception_cases = [bv for bv in boundaries if bv.expected_behavior == "raise_exception"]
```

## 与其他测试工具的集成

### 与 Hypothesis 集成

边界值生成器可以与 Hypothesis 的基于属性的测试结合使用：

```python
from hypothesis import given, strategies as st
from tests.helpers.boundary_generator import BoundaryValueGenerator

generator = BoundaryValueGenerator()
boundaries = generator.generate_string_boundaries()

@given(st.sampled_from([bv.value for bv in boundaries]))
def test_with_hypothesis(value):
    """使用 Hypothesis 测试边界值"""
    result = function_under_test(value)
    assert result is not None or value == ""
```

### 与 pytest fixtures 集成

```python
@pytest.fixture
def boundary_generator():
    """提供边界值生成器 fixture"""
    return BoundaryValueGenerator()

@pytest.fixture
def string_boundaries(boundary_generator):
    """提供字符串边界值 fixture"""
    return boundary_generator.generate_string_boundaries()

def test_with_fixture(string_boundaries):
    """使用 fixture 测试"""
    for boundary in string_boundaries:
        # 测试逻辑
        pass
```

## 总结

`BoundaryValueGenerator` 是一个强大的测试工具，可以帮助开发者：

1. 系统化地测试边界情况
2. 自动生成测试用例
3. 提高测试覆盖率
4. 发现潜在的边界情况 bug

通过使用这个工具，可以确保代码在各种边界条件下都能正确处理，提高代码的健壮性和可靠性。
